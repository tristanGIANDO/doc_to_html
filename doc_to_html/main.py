from pathlib import Path
import ast
import re

import envs


DOCSTRINGS = {}


def extract_docstrings(node):
    """
     Extracts docstrings from function or class definitions and stores them in
     a dictionary. The dictionary is keyed by name and contains information
     about the function or class that is defined in the docstring.

     Args:
        node: The node to extract the docstrings from.

     Returns:
        A dictionary of docstrings extracted from the node and stored in the
        dictionary under the node's name
    """
    global DOCSTRINGS
    if isinstance(node, ast.FunctionDef) \
            or isinstance(node, ast.AsyncFunctionDef):

        # Add a def definition to DOCSTRINGS dictionary.
        if node.body and isinstance(node.body[0], ast.Expr) \
                and isinstance(node.body[0].value, ast.Constant):

            docstring = node.body[0].value.s
            description = extract_description(docstring)
            args_section, returns_section = extract_args_returns(docstring)

            DOCSTRINGS[node.name] = {
                "type": "def",
                "desc": description,
                "args": args_section,
                "returns": returns_section}

    elif isinstance(node, ast.ClassDef):

        # Add a class definition to DOCSTRINGS dictionary.
        if node.body and isinstance(node.body[0], ast.Expr) \
                and isinstance(node.body[0].value, ast.Constant):

            docstring = node.body[0].value.s
            description = extract_description(docstring)
            args_section, returns_section = extract_args_returns(docstring)

            DOCSTRINGS[node.name] = {
                "type": "class",
                "desc": description,
                "args": args_section,
                "returns": returns_section}

    # Extract docstrings from all child nodes.
    for child_node in ast.iter_child_nodes(node):
        extract_docstrings(child_node)

    return DOCSTRINGS


def extract_args_returns(docstring):
    """
     Extract args and returns from docstrings.

     Args:
        docstring: The docstring to parse. Must be a string of the form
        "Args :" followed by a list of strings.

     Returns:
        A tuple of two lists. The first list is a list of arguments that were
        passed to the function. The second list is the section that contains
        the return values
    """
    args_match = re.search(r'Args:(.*?)(?:(?:Returns)|(?:Raises)|\Z)',
                           docstring,
                           re.DOTALL)

    returns_match = re.search(r'Returns:(.*?)(?:(?:Raises)|\Z)',
                              docstring,
                              re.DOTALL)

    args_section = args_match.group(1).strip() if args_match else None
    returns_section = returns_match.group(1).strip() if returns_match else None

    args_list = parse_args(args_section) if args_section else None

    return args_list, returns_section


def parse_args(args_section):
    """
     Parse arguments section and return list of arguments. This function is
     used to parse command line arguments from the config file.

     Args:
        args_section: String containing the section of arguments.

     Returns:
        List of tuples ( name description ) where name is the name of the
        argument and description is the description
    """
    arg_pattern = re.compile(r'\s*([\w\d_]+)\s*:(.*)')
    args_list = []

    # Parses the arguments section of the command line.
    for line in args_section.splitlines():
        match = arg_pattern.match(line)
        # Add a new argument to the list of arguments.
        if match:
            arg_name = match.group(1)
            arg_description = match.group(2).strip()
            args_list.append((arg_name, arg_description))

    return args_list


def extract_description(docstring: str):
    """
     Extract and return the description from a doc string. This is used to
     extract the description from the docstring that is
     generated by : func : ` generate_docstring `.

     Args:
        docstring: The docstring to extract the description from. It should be
        formatted as :.

     Returns:
        The description or None if there is no description in the docstring
        (as opposed to an empty string
    """
    sentences = re.split(r'(?<!\w\.\w.)(?<![A-Z][a-z]\.)(?<=\.|\?)\s',
                         docstring)

    return sentences[0] if sentences else None


def build_context(node: str) -> dict:
    """
     Builds and returns context for a node. This is used to generate HTML that
     can be embedded in a template.

     Args:
        node: Name of the node. Must be in DOCSTRINGS.

     Returns:
        Dictionary with information about the node's type ( str ) description
        ( str ) args_def ( list ) returns_def ( list )
    """
    global DOCSTRINGS

    args = DOCSTRINGS[node].get("args")
    # Generates a HTML string containing the arguments of the node.
    if args:
        args_names = []
        args_content = ""

        # Append the arguments to the args_names list of arguments.
        for arg in DOCSTRINGS[node].get("args"):
            args_content += f"""
        <p><strong>&nbsp; &nbsp; &nbsp; &nbsp;{arg[0]}</strong> : {arg[1]}</p>
        """
            args_names.append(arg[0])

    else:
        args_names = ""
        args_content = "<p>&nbsp; &nbsp; &nbsp; &nbsp;None</p>"

    context = {
        "type": DOCSTRINGS[node].get("type"),
        "node_name": node,
        "args_name": ", ".join(args_names),
        "description": DOCSTRINGS[node].get("desc"),
        "args_def": args_content,
        "returns_def": DOCSTRINGS[node].get("returns")
        }

    return context


def generate_documentation(input_file: str, output_directory: str) -> str:
    """
     Generate documentation for a file. This is a wrapper around
     extract_docstrings to get a list of docstrings and render them in the
     template

     Args:
        input_file: path to the file to generate documentation for
        output_directory: path to the directory to write the documentation to

     Returns:
        the HTML code that was generated or None if something went wrong during
        the generation of the documentation ( in which case it is printed
    """
    with open(input_file, 'r', encoding='utf-8') as file:
        source_code = file.read()

    try:
        tree = ast.parse(source_code)
        DOCSTRINGS = extract_docstrings(tree)
    except SyntaxError as e:
        print(f"Syntax error in file {input_file}: {e}")
        return

    input_path = Path(input_file)
    output_path = Path(output_directory)

    output_file = output_path / f"doc_{input_path.stem}.html"

    output_text = f"""
    {envs.html_start}
    <header>
        <h1>{input_path.stem}</h1>
    </header>
    """

    # Renders all the docstrings in the current document.
    for node in list(DOCSTRINGS.keys()):
        context = build_context(node)
        output_text += envs.template.render(context)

    output_text += envs.html_end

    file = open(output_file, "w")
    file.write(output_text)
    file.close()


# Generate documentation for the main module.
if __name__ == "__main__":
    import os
    root = os.path.dirname(__file__)

    generate_documentation(
        input_file=os.path.join(root, "example", "example_file.py"),
        output_directory=os.path.join(root, "example")
    )
